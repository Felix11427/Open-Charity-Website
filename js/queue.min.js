!function () {
    function createQueue(limit) {
        function processQueue() {
            while (currentIndex < taskList.length && activeTasks < limit) {
                let taskIndex = currentIndex++;
                let task = taskList[taskIndex];
                let args = Array.prototype.slice.call(task, 1);

                args.push(taskCallback(taskIndex));
                activeTasks++;
                task[0].apply(null, args);
            }
        }

        function taskCallback(index) {
            return function (error, result) {
                activeTasks--;
                if (finalError === null) {
                    if (error) {
                        finalError = error;
                        currentIndex = totalTasks = Infinity;
                        triggerCompletion();
                    } else {
                        taskList[index] = result;
                        remainingTasks--;
                        if (!remainingTasks && !activeTasks) {
                            triggerCompletion();
                        } else {
                            processQueue();
                        }
                    }
                }
            };
        }

        function triggerCompletion() {
            if (finalError !== null) {
                onComplete(finalError);
            } else if (awaitAllResults) {
                onComplete(null, taskList);
            } else {
                onComplete.apply(null, [null].concat(taskList));
            }
        }

        limit = limit || Infinity;

        let taskList = [];
        let currentIndex = 0;
        let activeTasks = 0;
        let remainingTasks = 0;
        let finalError = null;
        let awaitAllResults = false;
        let onComplete = defaultCallback;

        return {
            addTask: function () {
                if (!finalError) {
                    taskList.push(arguments);
                    remainingTasks++;
                    processQueue();
                }
                return this;
            },
            onComplete: function (callback) {
                onComplete = callback;
                awaitAllResults = false;
                if (!remainingTasks) triggerCompletion();
                return this;
            },
            onCompleteAll: function (callback) {
                onComplete = callback;
                awaitAllResults = true;
                if (!remainingTasks) triggerCompletion();
                return this;
            }
        };
    }

    function defaultCallback() { }

    createQueue.version = "2.0.0";

    if (typeof define === "function" && define.amd) {
        define(function () { return createQueue; });
    } else if (typeof module === "object" && module.exports) {
        module.exports = createQueue;
    } else {
        this.taskQueue = createQueue;
    }
}();
